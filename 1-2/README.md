pi, pi -> str: см. РК

z -> pi:
Если z[i]>0, то для всех элементов с индексом i+ j, где 0 <= j < z[i], значение p[i + j] будет не меньше, чем длина подстроки с i по i+j. Изменение значения уже инициализированного p[i + j] только уменьшит значение. Значит, идем слева направо по массиву z и, находясь на позиции i, пытаемся записать в p от позиции i+z[i]−1 до i значение j+1, где j пробегает все значения 0…z[i]−1, пока не наткнемся на уже инициализированный элемент. Работает за линию, т.к. каждый элемент инициализируем только один раз.

z, z -> str: см. РК

pi -> z:
Пусть префикс функция хранится в массиве P[0…n−1]. Z-функцию будем записывать в массив Z[0…n−1]. Заметим, что если P[i]>0, то мы можем заявить, что Z[i−P[i]+1] будет не меньше, чем P[i].

Так же заметим, что после такого прохода в Z[1] будет максимальное возможное значение. Далее будем поддерживать инвариант: в Z[i] будет максимальное возможное значение.

Пусть в Z[i]=z>0, рассмотрю j<z, Z[j]=k и Z[i+j]=k1. Пусть b1=s[0…k−1], b2=s[j…j+k−1], b3=s[0…z−1]. Тогда заметим, что b3=s[i…i+z−1] и тогда возможны три случая:

1) k<k1.
Тогда b1⊂s[0…k1−1]=s[i+j…i+j+k1−1] и тогда очевидно, что мы не можем увеличить значение Z[i+j] и надо рассматривать уже i=i+j.
2) k<z−j и k>k1.
Тогда b1=b2⊂b3=s[i…i+z−1]⇒b1=s[i+j…i+j+k−1] и тогда очевидно, что Z[i+j] можно увеличить до k.
3) k>z−j и k>k1.
Тогда b1=b2, но b2 не является подстрокой строки b3 (так какj+k−1>z). Так как известно, что s[z]≠s[i+z], то s[0…z−j]=s[i+j…i+z−1] и тогда понятно, что Z[i+j]=z−j.